% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

В данном разделе рассмотрены основные подходы и технологии, применяемые для извлечения данных с веб-страниц, а также существующие в литературе методы, близкие по назначению к задачам автоматизированного парсинга. Описаны их преимущества и недостатки с точки зрения универсальности, надёжности и затрат вычислительных ресурсов.

\subsection{Методы парсинга веб-страниц}

Существует два классических метода парсинга веб-страниц: \emph{статический} и \emph{динамический}.

\paragraph{Статический парсинг} предполагает получение HTML-исходников напрямую через HTTP-запросы. Данный подход широко используется благодаря простоте реализации и высокой скорости работы. Типовой стек включает:
\begin{itemize}
    \item \textbf{Requests} — библиотека для отправки HTTP-запросов (документация Python\cite{python-official}).
    \item \textbf{BeautifulSoup4}\cite{bs4-doc} — парсер HTML/XML, позволяющий строить дерево тегов, искать элементы по селекторам и извлекать текст. Этот метод эффективен для страниц, контент которых формируется на сервере, но не подходит для SPA.
\end{itemize}
Преимущества статического подхода:
\begin{itemize}
    \item высокая производительность (ограничивается временем сетевых запросов и обработкой текста);
    \item простота отладки и воспроизводимость результатов при неизменном HTML.
\end{itemize}
Недостатки:
\begin{itemize}
    \item неспособность корректно обрабатывать страницы с интенсивным JavaScript;
    \item необходимость ручного написания селекторов для каждой новой страницы.
\end{itemize}

\paragraph{Динамический парсинг} предполагает эмуляцию браузера и выполнение JavaScript для получения «отрендеренного» DOM. К популярным инструментам относится:
\begin{itemize}
    \item \textbf{Selenium}\cite{selenium-doc} — фреймворк для автоматизации браузера, позволяющий запускать Chrome/Firefox в фоновом режиме, ждать загрузки страницы и затем извлекать итоговый HTML. Такой метод подходит для современных SPA, но более медленный и ресурсоёмкий по сравнению со статическим парсингом.
\end{itemize}
Преимущества:
\begin{itemize}
    \item возможность корректной обработки JavaScript-контента;
    \item высокая точность извлечения данных с динамических страниц.
\end{itemize}
Недостатки:
\begin{itemize}
    \item значительные накладные расходы на запуск браузера и ожидание рендеринга;
    \item зависимость от версий браузерных движков и драйверов.
\end{itemize}

\paragraph{Подходы на основе языковых моделей (LLM)} приобрели популярность после публикации работы Brown et al.\cite{brown2020language}, где продемонстрированы возможности LLM в «few-shot» режиме. В контексте парсинга LLM применяются в двух основных режимах:
\begin{itemize}
    \item \emph{Структурирование} (structuring) — LLM получает на вход очищенный HTML и текстовое описание необходимых полей, после чего возвращает готовую JSON-структуру. Этот метод снимает необходимость ручного написания селекторов, но многократные запросы к LLM могут быть дорогостоящими и медленными.
    \item \emph{Генерация кода} (codegen) — LLM формирует фрагмент Python-скрипта, который затем выполняется локально для извлечения данных. Такой подход сочетает гибкость LLM и возможность дальнейшей повторной работы без дополнительных запросов к модели.
\end{itemize}
Преимущества LLM-подходов:
\begin{itemize}
    \item высокая адаптивность к разнообразным HTML-структурам;
    \item возможность «понимания» семантики страницы без явного знания её DOM-структуры.
\end{itemize}
Недостатки:
\begin{itemize}
    \item необходимость вычислительных ресурсов и ограничение по числу токенов при обращении к облачным API;
    \item задержки при получении ответа от модели (latency);
    \item нестабильность результатов в «zero-shot» условиях.
\end{itemize}

\subsection{Используемые технологии}

Ниже приведён перечень ключевых технологий, используемых для реализации системы парсинга.

\paragraph{Язык программирования}
\begin{itemize}
    \item \textbf{Python}\cite{python-official} — выбран за счёт развитой экосистемы для веб-разработки, парсинга HTML и взаимодействия с LLM, а также встроенной поддержки SQLite.
\end{itemize}

\paragraph{HTTP-запросы и статический парсинг}
\begin{itemize}
    \item \textbf{Requests} (через\cite{python-official}) — инструмент для отправки HTTP-запросов в Python.
    \item \textbf{BeautifulSoup4}\cite{bs4-doc} — библиотека для парсинга HTML и XML.
\end{itemize}

\paragraph{Динамический парсинг}
\begin{itemize}
    \item \textbf{Selenium}\cite{selenium-doc} — фреймворк для автоматизации браузера, позволяющий получать «отрендеренный» HTML.
\end{itemize}

\paragraph{LLM-интеграция}
\begin{itemize}
    \item \textbf{MistralAI (mistralai Python SDK)}\cite{mistral-github} — клиентская библиотека для работы с LLM Mistral.
    \item \textbf{tiktoken}\cite{tiktoken-github} — утилита для подсчёта токенов, оптимизирующая стоимость запросов к LLM.
    \item \textbf{Brown et al.\cite{brown2020language}} — базовая статья, демонстрирующая потенциал LLM в режиме «few-shot».
\end{itemize}

\paragraph{Хранение кэша}
\begin{itemize}
    \item \textbf{SQLite (\texttt{sqlite3})}\cite{sqlite-official} — встраиваемая SQL-база для хранения метаданных и кэшированных скриптов.
\end{itemize}

\paragraph{Пользовательские интерфейсы}
\begin{itemize}
    \item \textbf{FastAPI}\cite{fastapi-official} — фреймворк для разработки REST-API.
    \item \textbf{Gradio}\cite{gradio-official} — библиотека для быстрой разработки веб-интерфейсов, развёртываемых в Hugging Face Space.
    \item \textbf{Jinja2}\cite{jinja2-official} — шаблонизатор для генерации HTML-страниц в веб-приложении.
\end{itemize}

\subsection{Выводы}

Из анализа существующих решений следует, что статический парсинг (Requests + BeautifulSoup4) эффективен для простых HTML-страниц, но не справляется с динамическими приложениями, требующими JavaScript (Selenium). Применение LLM (см.\cite{brown2020language}) открывает новые возможности автоматизации, однако требует значительных ресурсов и времени. Для создания универсального решения оправдан комбинированный подход, сочетающий традиционные методы парсинга с LLM-интеграцией и кэшированием, что позволяет оптимизировать вычислительные расходы и обеспечить повторный доступ к ранее сгенерированным парсер-скриптам.
